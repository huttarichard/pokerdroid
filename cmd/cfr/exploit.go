package cmdcfr

import (
	"log"
	"os"
	"os/signal"

	absp "github.com/pokerdroid/poker/abs/pack"
	"github.com/pokerdroid/poker/cfr"
	holdemdealer "github.com/pokerdroid/poker/dealer/holdem"
	"github.com/pokerdroid/poker/frand"
	"github.com/pokerdroid/poker/tree"
	"github.com/spf13/cobra"
)

type exploitArgs struct {
	tree       string
	abs        string
	iterations uint64
}

var ef = exploitArgs{}

func init() {
	flags := exploitCMD.Flags()

	flags.StringVar(&ef.tree, "tree", "", "path to the tree")
	flags.StringVar(&ef.abs, "abs", "", "path to the abstraction")

	flags.Uint64Var(&ef.iterations, "iterations", 100_000, "how many iterations to run")

	cobra.MarkFlagRequired(flags, "db")
	cobra.MarkFlagRequired(flags, "tree")
	cobra.MarkFlagRequired(flags, "abs")
}

var exploitCMD = &cobra.Command{
	Use:   "exploit",
	Short: "will measure exploitability",

	Run: func(cmd *cobra.Command, args []string) {
		ctx, cancel := signal.NotifyContext(cmd.Context(), os.Interrupt)
		defer cancel()

		logger := log.Default()
		logger.Print("loading abstraction")

		abs, err := absp.NewFromFile(ef.abs)
		if err != nil {
			log.Fatal(err)
		}

		game, err := tree.NewFromFile(ef.tree)
		if err != nil {
			log.Fatal(err)
		}

		logger.Print("running exploit")

		params := holdemdealer.SamplerParams{
			NumPlayers: game.Params.NumPlayers,
		}

		exploit := cfr.Exploit(ctx, cfr.ExploitParams{
			Root:       game,
			Params:     game.Params,
			Sampler:    holdemdealer.New(params),
			Rng:        frand.NewUnsafe(),
			Iterations: ef.iterations,
			Abs:        abs,
		})

		logger.Printf("exploitability: %f", exploit)

	},
}
