package cfr

import (
	"context"
	"runtime"
	"sync"

	"github.com/pokerdroid/poker/abs"
	"github.com/pokerdroid/poker/dealer"
	"github.com/pokerdroid/poker/float/f64"
	"github.com/pokerdroid/poker/frand"
	"github.com/pokerdroid/poker/table"
	"github.com/pokerdroid/poker/tree"
)

type ExploitParams struct {
	Sampler    dealer.Dealer
	Rng        frand.Rand
	Root       *tree.Root
	Params     table.GameParams
	Iterations uint64
	Workers    int
	Abs        abs.Mapper
}

// Exploit concurrently computes the exploitability by dividing the total
// iterations among several workers. Each worker computes a local best-response
// value (using BR.Run) and the final exploitability is the weighted average.
func Exploit(ctx context.Context, p ExploitParams) float64 {
	if p.Workers == 0 {
		p.Workers = runtime.NumCPU()
	}

	var wg sync.WaitGroup

	// We'll accumulate sums of player0 and player1 differences
	var sum float64
	var total float64

	iters := p.Iterations / uint64(p.Workers)

	for w := 0; w < p.Workers; w++ {
		wg.Add(1)
		go func(numIters uint64, rng frand.Rand) {
			defer wg.Done()

			// Respect cancellation
			select {
			case <-ctx.Done():
				return
			default:
			}

			// Calculate BR for player 1
			local := RunExploitParams{
				Game:       p.Root,
				Params:     p.Params,
				Abs:        p.Abs,
				Iterations: numIters,
				Sampler:    p.Sampler.Clone(),
				Rng:        rng,
			}

			result := RunExploit(local)

			// Atomically accumulate
			// for a real production code, protect with a sync.Mutex or use atomic.
			sum += result
			total++
		}(iters, frand.Clone(p.Rng))
	}

	wg.Wait()

	if total == 0 {
		return 0
	}

	return sum / total
}

type RunExploitParams struct {
	Game       *tree.Root
	Params     table.GameParams
	Abs        abs.Mapper
	Iterations uint64
	Sampler    dealer.Dealer
	Rng        frand.Rand
}

func RunExploit(p RunExploitParams) float64 {
	np := p.Params.NumPlayers

	if np != 2 {
		panic("only 2-player games are supported")
	}

	// One accumulator per player
	var out float64

	brr := &BR{game: p.Game, abs: p.Abs}
	evr := &EV{game: p.Game, abs: p.Abs}

	for i := uint64(0); i < p.Iterations; i++ {
		sample, err := p.Sampler.Sample(p.Rng)
		if err != nil {
			panic(err)
		}

		// t1 := uint8(i % 2)
		// t2 := uint8(1 - t1)

		br0 := brr.Get(p.Rng, sample, 0)
		ev0 := evr.Get(p.Rng, sample, 0)

		br1 := brr.Get(p.Rng, sample, 1)
		ev1 := evr.Get(p.Rng, sample, 1)

		out += ((br0 - ev0) + (br1 - ev1)) / 2

		p.Sampler.Put(sample)
	}

	return out / float64(p.Iterations)
}

type BR struct {
	game *tree.Root
	abs  abs.Mapper
}

func (c *BR) Get(rng frand.Rand, sample dealer.Sample, pid uint8) (ev float64) {
	t := &Task{TraversingID: pid, Sample: sample, Rng: rng}
	return c.runHelper(c.game, pid, t)
}

func (c *BR) runHelper(n tree.Node, lp uint8, t *Task) (ev float64) {
	switch x := n.(type) {
	case *tree.Root:
		ev = c.runHelper(x.Next, lp, t)

	case *tree.Terminal:
		ev = t.Sample.Utility(x, t.TraversingID)

	case *tree.Chance:
		t.Sample.Sample(x.State.Street)
		ev = c.runHelper(x.Next, lp, t)

	case tree.DecisionPoint:
		if x.GetTurnPos() == t.TraversingID {
			ev = c.br(x, t)
		} else {
			ev = c.sampling(x, t)
		}

	case nil:
		return 0

	default:
		panic("unknown node")
	}

	return ev
}

func (c *BR) br(n tree.DecisionPoint, t *Task) (ev float64) {
	anl := n.Len()
	if anl == 0 {
		return 0
	}
	evs := make([]float64, anl)

	for i := 0; i < anl; i++ {
		if n.IsNil(i) {
			evs[i] = float64(-c.game.Params.InitialStacks[t.TraversingID])
			continue
		}

		util := c.runHelper(n.GetNode(i), n.GetTurnPos(), t)
		evs[i] = util
	}

	return f64.Max(evs...)
}

func (c *BR) sampling(n tree.DecisionPoint, t *Task) (ev float64) {
	cluster := t.Sample.Cluster(n, c.abs)

	anl := n.Len()
	if anl == 0 {
		return 0
	}
	evs := make([]float64, anl)

	// if policy does not exist we assume
	// neutral outcome
	pol, ok := n.Get(cluster)
	if !ok {
		return 0
	}

	avg := pol.GetAverageStrategy()

	for i := 0; i < anl; i++ {
		if n.IsNil(i) {
			evs[i] = 0
			continue
		}

		util := c.runHelper(n.GetNode(i), n.GetTurnPos(), t)
		evs[i] = util
	}

	return f64.DotUnitary(avg, evs)
}

// EV calculates the expected value when both players
// use their current average strategy
type EV struct {
	game *tree.Root
	abs  abs.Mapper
}

func (c *EV) Get(rng frand.Rand, sample dealer.Sample, pid uint8) (ev float64) {
	t := &Task{TraversingID: pid, Sample: sample, Rng: rng}
	return c.runHelper(c.game, pid, t)
}

func (c *EV) runHelper(n tree.Node, lp uint8, t *Task) (ev float64) {
	switch x := n.(type) {
	case *tree.Root:
		ev = c.runHelper(x.Next, lp, t)

	case *tree.Terminal:
		ev = t.Sample.Utility(x, t.TraversingID)

	case *tree.Chance:
		t.Sample.Sample(x.State.Street)
		ev = c.runHelper(x.Next, lp, t)

	case tree.DecisionPoint:
		// Use sampling for all players' decisions
		ev = c.sampling(x, t)

	case nil:
		return 0

	default:
		panic("unknown node")
	}

	return ev
}

func (c *EV) sampling(n tree.DecisionPoint, t *Task) (ev float64) {
	cluster := t.Sample.Cluster(n, c.abs)

	anl := n.Len()
	if anl == 0 {
		return 0
	}
	evs := make([]float64, anl)

	pol, ok := n.Get(cluster)
	if !ok {
		return 0 // Neutral outcome for missing policies
	}

	avg := pol.GetAverageStrategy()

	for i := 0; i < anl; i++ {
		if n.IsNil(i) {
			evs[i] = float64(-c.game.Params.InitialStacks[t.TraversingID])
			continue
		}

		util := c.runHelper(n.GetNode(i), n.GetTurnPos(), t)
		evs[i] = util
	}

	return f64.DotUnitary(avg, evs)
}
